{"name":"Dynaconf","tagline":"Dynamic config load for Python ","body":"\r\n<img src=\"https://raw.githubusercontent.com/rochacbruno/dynaconf/master/dynaconf_joystick.png\" align=\"left\" width=\"192px\" height=\"192px\"/>\r\n<img align=\"left\" width=\"0\" height=\"192px\" hspace=\"10\"/>\r\n\r\n> **dynaconf** - The **dyna**mic **conf**igurator for your Python Project \r\n\r\n[![MIT License](https://img.shields.io/badge/license-MIT-007EC7.svg?style=flat-square)](/LICENSE) [![PyPI](https://img.shields.io/pypi/v/dynaconf.svg)](https://pypi.python.org/pypi/dynaconf) [![downloads](https://img.shields.io/pypi/dw/dynaconf.svg)](https://pypi.python.org/pypi/dynaconf) [![Travis CI](http://img.shields.io/travis/rochacbruno/dynaconf.svg)](https://travis-ci.org/rochacbruno/dynaconf) [![Coverage Status](https://coveralls.io/repos/rochacbruno/dynaconf/badge.svg?branch=master&service=github)](https://coveralls.io/github/rochacbruno/dynaconf?branch=master) [![Code Health](https://landscape.io/github/rochacbruno/dynaconf/master/landscape.svg?style=flat)](https://landscape.io/github/rochacbruno/dynaconf/master)\r\n\r\n\r\n**dynaconf** is an OSM (**O**bject **S**ettings **M**apper) it can read settings variables from a set of different data stores such as **python settings files**, **environment variables**, **redis**, **memcached**, **ini files**, **json files**, **yaml files** and you can customize **dynaconf** loaders to read from wherever you want. (maybe you really want to read from xml files ughh?)\r\n\r\n<br><br>\r\n\r\n# Install\r\n```bash\r\npip install dynaconf\r\n```\r\n\r\n# define your settings module\r\n\r\n```bash\r\nexport DYNACONF_SETTINGS=myproject.settings\r\nor\r\nexport DYNACONF_SETTINGS=myproject.production_settings\r\nor\r\nexport DYNACONF_SETTINGS=/etc/myprogram/settings.py\r\n```\r\n\r\n# you can export extra values\r\n\r\n```bash\r\nexport DYNACONF_DATABASE='mysql://....'\r\nexport DYNACONF_SYSTEM_USER='admin'\r\nexport DYNACONF_FOO='bar'\r\n```\r\n\r\nOr define all your settings as env_vars starting with **DYNACONF_**\r\n\r\n# Example\r\n\r\n```bash\r\nexport DYNACONF_SETTINGS=myproject.settings\r\n```\r\n\r\n### file: myproject/settings.py\r\n```python\r\nNAME = 'Bruno'\r\n```\r\n\r\n### file:app.py\r\n```python\r\n\r\nfrom dynaconf import settings\r\n\r\nprint settings.NAME\r\nprint settings.DATABASE\r\nprint settings.SYSTEM_USER\r\nprint settings.get('FOO')\r\n```\r\n\r\n### then\r\n\r\n```bash\r\npython app.py\r\n\r\nBruno\r\nmysql://..\r\nadmin\r\nbar\r\n```\r\n\r\n# Namespace support\r\n\r\nWhen you are working with multiple projects using the same environment maybe you want to use different namespaces for ENV vars based configs\r\n\r\n\r\n```bash\r\nexport DYNACONF_DATABASE=\"DYNADB\"\r\nexport PROJ1_DATABASE=\"PROJ1DB\"\r\nexport PROJ2_DATABASE=\"PROJ2DB\"\r\n```\r\n\r\nand then access them\r\n\r\n\r\n```python\r\nfrom dynaconf import settings\r\n\r\n# configure() or configure('settingsmodule.path') is needed\r\n# only when DYNACONF_SETINGS is not defined\r\nsettings.configure()\r\n\r\n# access default namespace settings\r\nsettings.DATABASE\r\n'DYNADB'\r\n\r\n# switch namespaces\r\nsettings.namespace('PROJ1')\r\nsettings.DATABASE\r\n'PROJ1DB'\r\n\r\nsettings.namespace('PROJ2')\r\nsettings.DATABASE\r\n'PROJ2DB'\r\n\r\n# return to default, call it without args\r\nsettings.namespace()\r\nsettings.DATABASE\r\n'DYNADB'\r\n```\r\n\r\nYou can also use the context manager:\r\n\r\n```python\r\nsettings.DATABASE\r\n'DYNADB'\r\n\r\nwith settings.using_namespace('PROJ1'):\r\n    settings.DATABASE\r\n    'PROJ1DB'\r\n\r\nwith settings.using_namespace('PROJ2'):\r\n    settings.DATABASE\r\n    'PROJ2DB'\r\n\r\nsettings.DATABASE\r\n'DYNADB'\r\n```\r\n\r\n> namespace() and using_namespace() takes optional argument **clean** defaults to True. If you want to keep the pre-loaded values when switching namespaces set it to False.\r\n\r\n# casting values from envvars\r\n\r\nSometimes you need to set some values as specific types, boolean, integer, float or lists and dicts.\r\n\r\nbuilt in casts\r\n\r\n- @int (as_int)\r\n- @bool (as_bool)\r\n- @float (as_float)\r\n- @json (as_json)\r\n\r\n> @json / as_json  will use json to load a Python object from string, it is useful to get lists and dictionaries. The return is always a Python object.\r\n\r\nstrings does not need converters.\r\n\r\nYou have 2 ways to use the casts.\r\n\r\n### Casting on declaration\r\n\r\nJust start your ENV settigs with this\r\n\r\n```bash\r\nexport DYNACONF_DEFAULT_THEME='material'\r\nexport DYNACONF_DEBUG='@bool True'\r\nexport DYNACONF_DEBUG_TOOLBAR_ENABLED='@bool False'\r\nexport DYNACONF_PAGINATION_PER_PAGE='@int 20'\r\nexport DYNACONF_MONGODB_SETTINGS='@json {\"DB\": \"quokka_db\"}'\r\nexport DYNACONF_ALLOWED_EXTENSIONS='@json [\"jpg\", \"png\"]'\r\n```\r\n\r\nStarting the settings values with @ will make dynaconf.settings to cast it in the time od load.\r\n\r\n### Casting on access\r\n\r\n```bash\r\nexport DYNACONF_USE_SSH='yes'\r\n\r\nfrom dynaconf import settings\r\n\r\n```\r\n\r\n```python\r\n\r\nuse_ssh = settings.get('USE_SSH', cast='@bool')\r\n# or\r\nuse_ssh = settings('USE_SSH', cast='@bool')\r\n# or\r\nuse_ssh = settings.as_bool('USE_SSH')\r\n\r\nprint use_ssh\r\n\r\nTrue\r\n```\r\n\r\n### more examples\r\n\r\n```bash\r\nexport DYNACONF_USE_SSH='enabled'\r\n\r\nexport DYNACONF_ALIST='@json [1,2,3]'\r\nexport DYNACONF_ADICT='@json {\"name\": \"Bruno\"}'\r\nexport DYNACONF_AINT='@int 42'\r\nexport DYNACONF_ABOOL='@bool on'\r\nexport DYNACONF_AFLOAT='@float 42.5'\r\n```\r\n\r\n```python\r\n\r\nfrom dynaconf import settings\r\nsettings.configure()\r\n\r\n# original value\r\nsettings('USE_SSH')\r\n'enabled'\r\n\r\n# cast as bool\r\nsettings('USE_SSH', cast='@bool')\r\nTrue\r\n\r\n# also cast as bool\r\nsettings.as_bool('USE_SSH')\r\nTrue\r\n\r\n# cast defined in declaration '@bool on'\r\nsettings.ABOOL\r\nTrue\r\n\r\n# cast defined in declaration '@json {\"name\": \"Bruno\"}'\r\nsettings.ADICT\r\n{u'name': u'Bruno'}\r\n\r\n# cast defined in declaration '@json [1,2,3]'\r\nsettings.ALIST\r\n[1, 2, 3]\r\n\r\n# cast defined in decalration '@float 42.5'\r\nsettings.AFLOAT\r\n42.5\r\n\r\n# cast defined in declaration '@int 42'\r\nsettings.AINT\r\n42\r\n\r\n```\r\n\r\n# Defining default namespace\r\n\r\nInclude in the file defined in DYNACONF_SETTINGS the desired namespace\r\n\r\n```python\r\nDYNACONF_NAMESPACE = 'DYNACONF'\r\n```\r\n\r\n# Storing settings in databases\r\n\r\n## Using REDIS\r\n\r\nRedis support relies on the following two settings that you can setup in the DYNACONF_SETTINGS file\r\n\r\n\r\n1  Add the configuration for redis client\r\n```python\r\nREDIS_FOR_DYNACONF = {\r\n    'host': 'localhost',\r\n    'port': 6379,\r\n    'db': 0\r\n}\r\n\r\n```\r\n\r\n\r\n\r\nInclude **redis_loader** in dynaconf LOADERS_FOR_DYNACONF\r\n\r\n> the order is the precedence\r\n\r\n```python\r\n\r\n# Loaders to read namespace based vars from diferent data stores\r\nLOADERS_FOR_DYNACONF = [\r\n    'dynaconf.loaders.env_loader',\r\n    'dynaconf.loaders.redis_loader'\r\n]\r\n```\r\n\r\nYou can now write variables direct in to a redis hash named `DYNACONF_< NAMESPACE >`\r\n\r\nBy default **DYNACONF_DYNACONF**\r\n\r\n\r\nYou can also use the redis writer\r\n\r\n```python\r\nfrom dynaconf.utils import redis_writer\r\nfrom dynaconf import settings\r\n\r\nredis_writer.write(settings, name='Bruno', database='localhost', PORT=1234)\r\n\r\n```\r\n\r\nThe above data will be converted to namespaced values and recorded in redis as a hash:\r\n\r\n```\r\nDYNACONF_DYNACONF:\r\n    NAME='Bruno'\r\n    DATABASE='localhost'\r\n    PORT='@int 1234'\r\n```\r\n\r\n> if you want to skip type casting, write as string intead of PORT=1234 use PORT='1234' as redis stores everything as string anyway\r\n\r\nData is read from redis and another loaders only once or when namespace() and using_namespace() are invoked. You can access the fresh value using **settings.get_fresh(key)**\r\n\r\nThere is also the **fresh** context manager\r\n\r\n```python\r\nfrom dynaconf import settings\r\n\r\nprint settings.FOO  # this data was loaded once on import\r\n\r\nwith settings.fresh():\r\n    print settings.FOO  # this data is being directly read from loaders\r\n\r\n```\r\n\r\nAnd you can also force some variables to be **fresh** setting in your setting file\r\n\r\n```python\r\nDYNACONF_ALWAYS_FRESH_VARS = ['MYSQL_HOST']\r\n```\r\n\r\nor using env vars\r\n\r\n```bash\r\nexport DYNACONF_ALWAYS_FRESH_VARS='@json [\"MYSQL_HOST\"]'\r\n```\r\n\r\nThen\r\n\r\n```python\r\nfrom dynaconf import settings\r\n\r\nprint settings.FOO  # This data was loaded once on import\r\n\r\nprint settings.MYSQL_HOST # This data is being read from redis imediatelly!\r\n\r\n```\r\n\r\n# Using programatically\r\n\r\nSometimes you want to override settings for your existing Package or Framework\r\nlets say you have a **conf** module exposing a **settings** object and used to do:\r\n\r\n`from myprogram.conf import settings`\r\n\r\nNow you want to use Dynaconf, open that `conf.py` or `conf/__init__.py` and do:\r\n\r\n```python\r\n# coding: utf-8\r\nfrom dynaconf import LazySettings\r\n\r\nsettings = LazySettings(\r\n    ENVVAR_FOR_DYNACONF=\"MYPROGRAM_SETTINGS_MODULE\",\r\n    DYNACONF_NAMESPACE='MYPROGRAM'\r\n)\r\n\r\n```\r\n\r\nNow you can import settings from your own program and dynaconf will do the rest!\r\n\r\n> This was inspired by flask.config and django.conf.settings\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}